#!/usr/bin/env node

/**
 * ÊßãÈÄ†Âåñ„Éá„Éº„ÇøËá™ÂãïÊ§úË®º„Çπ„ÇØ„É™„Éó„Éà
 *
 * Êú¨Áï™Áí∞Â¢É„ÅÆ„Éö„Éº„Ç∏„Åã„ÇâÊßãÈÄ†Âåñ„Éá„Éº„ÇøÔºàJSON-LDÔºâ„ÇíÊäΩÂá∫„Åó„Å¶Ê§úË®º„Åó„Åæ„Åô„ÄÇ
 *
 * ‰ΩøÁî®ÊñπÊ≥ï:
 *   node scripts/validate-structured-data.mjs
 *   node scripts/validate-structured-data.mjs --url https://suptia.com/products/slug
 *   node scripts/validate-structured-data.mjs --type product
 *   node scripts/validate-structured-data.mjs --verbose
 */

import https from 'https';
import http from 'http';
import { JSDOM } from 'jsdom';

const SITE_URL = 'https://suptia.com';

// „ÉÜ„Çπ„ÉàÂØæË±°URL
const TEST_URLS = {
  products: [
    '/products/5-6-diet-1',
    '/products/1-150-diet-1',
    '/products/1-150-magnesium-supplement-diet',
  ],
  ingredients: [
    '/ingredients/beta-alanine',
    '/ingredients/coq10',
    '/ingredients/echinacea',
  ],
  lists: [
    '/products',
    '/ingredients',
  ],
  diagnosis: [
    '/diagnosis',
  ],
};

// „Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥ÂºïÊï∞„Éë„Éº„Çπ
const args = process.argv.slice(2);
const options = {
  url: args.find(arg => arg.startsWith('--url='))?.split('=')[1],
  type: args.find(arg => arg.startsWith('--type='))?.split('=')[1],
  verbose: args.includes('--verbose') || args.includes('-v'),
};

/**
 * HTTPS„É™„ÇØ„Ç®„Çπ„Éà„ÅßHTML„ÇíÂèñÂæó
 */
function fetchHtml(url) {
  return new Promise((resolve, reject) => {
    const protocol = url.startsWith('https') ? https : http;

    protocol.get(url, (res) => {
      let data = '';

      res.on('data', (chunk) => {
        data += chunk;
      });

      res.on('end', () => {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          resolve(data);
        } else {
          reject(new Error(`HTTP ${res.statusCode}: ${url}`));
        }
      });
    }).on('error', reject);
  });
}

/**
 * HTML„Åã„ÇâJSON-LDÊßãÈÄ†Âåñ„Éá„Éº„Çø„ÇíÊäΩÂá∫
 */
function extractJsonLd(html) {
  const dom = new JSDOM(html);
  const scripts = dom.window.document.querySelectorAll('script[type="application/ld+json"]');

  const jsonLdData = [];
  scripts.forEach(script => {
    try {
      const data = JSON.parse(script.textContent);
      jsonLdData.push(data);
    } catch (e) {
      console.error('‚ö†Ô∏è  JSON-LD parse error:', e.message);
    }
  });

  return jsonLdData;
}

/**
 * Product Schema„ÇíÊ§úË®º
 */
function validateProductSchema(data) {
  const errors = [];
  const warnings = [];

  if (data['@type'] !== 'Product') {
    errors.push('@type must be "Product"');
    return { valid: false, errors, warnings };
  }

  // ÂøÖÈ†à„Éï„Ç£„Éº„É´„Éâ
  if (!data.name) errors.push('Missing required field: name');
  if (!data.offers) errors.push('Missing required field: offers');

  // offersÊ§úË®º
  if (data.offers) {
    const offerType = data.offers['@type'];

    if (offerType === 'AggregateOffer') {
      if (!data.offers.lowPrice) errors.push('AggregateOffer missing lowPrice');
      if (!data.offers.highPrice) errors.push('AggregateOffer missing highPrice');
      if (!data.offers.offerCount) warnings.push('AggregateOffer missing offerCount');
      if (!data.offers.priceCurrency) errors.push('Missing priceCurrency');

      // ‰æ°Ê†º„ÅÆÂ¶•ÂΩìÊÄß„ÉÅ„Çß„ÉÉ„ÇØ
      if (data.offers.lowPrice && data.offers.highPrice) {
        if (data.offers.lowPrice > data.offers.highPrice) {
          errors.push('lowPrice cannot be greater than highPrice');
        }
      }
    } else if (offerType === 'Offer') {
      if (!data.offers.price) errors.push('Offer missing price');
      if (!data.offers.priceCurrency) errors.push('Missing priceCurrency');
    } else {
      errors.push(`Unknown offer type: ${offerType}`);
    }

    if (!data.offers.availability) warnings.push('Missing availability');
  }

  // Êé®Â•®„Éï„Ç£„Éº„É´„Éâ
  if (!data.description) warnings.push('Missing recommended field: description');
  if (!data.image) warnings.push('Missing recommended field: image');
  if (!data.brand) warnings.push('Missing recommended field: brand');

  return {
    valid: errors.length === 0,
    errors,
    warnings,
  };
}

/**
 * FAQ Schema„ÇíÊ§úË®º
 */
function validateFaqSchema(data) {
  const errors = [];
  const warnings = [];

  if (data['@type'] !== 'FAQPage') {
    errors.push('@type must be "FAQPage"');
    return { valid: false, errors, warnings };
  }

  if (!data.mainEntity || !Array.isArray(data.mainEntity)) {
    errors.push('Missing mainEntity array');
    return { valid: false, errors, warnings };
  }

  if (data.mainEntity.length === 0) {
    warnings.push('mainEntity is empty');
  }

  // ÂêÑË≥™Âïè„ÇíÊ§úË®º
  data.mainEntity.forEach((item, index) => {
    if (item['@type'] !== 'Question') {
      errors.push(`mainEntity[${index}]: @type must be "Question"`);
    }
    if (!item.name) {
      errors.push(`mainEntity[${index}]: Missing name (question text)`);
    }
    if (!item.acceptedAnswer) {
      errors.push(`mainEntity[${index}]: Missing acceptedAnswer`);
    } else {
      if (item.acceptedAnswer['@type'] !== 'Answer') {
        errors.push(`mainEntity[${index}]: acceptedAnswer @type must be "Answer"`);
      }
      if (!item.acceptedAnswer.text) {
        errors.push(`mainEntity[${index}]: acceptedAnswer missing text`);
      }
    }
  });

  return {
    valid: errors.length === 0,
    errors,
    warnings,
  };
}

/**
 * Breadcrumb Schema„ÇíÊ§úË®º
 */
function validateBreadcrumbSchema(data) {
  const errors = [];
  const warnings = [];

  if (data['@type'] !== 'BreadcrumbList') {
    errors.push('@type must be "BreadcrumbList"');
    return { valid: false, errors, warnings };
  }

  if (!data.itemListElement || !Array.isArray(data.itemListElement)) {
    errors.push('Missing itemListElement array');
    return { valid: false, errors, warnings };
  }

  if (data.itemListElement.length === 0) {
    errors.push('itemListElement is empty');
  }

  // ÂêÑ„Ç¢„Ç§„ÉÜ„É†„ÇíÊ§úË®º
  data.itemListElement.forEach((item, index) => {
    if (item['@type'] !== 'ListItem') {
      errors.push(`itemListElement[${index}]: @type must be "ListItem"`);
    }
    if (!item.position) {
      errors.push(`itemListElement[${index}]: Missing position`);
    } else if (item.position !== index + 1) {
      errors.push(`itemListElement[${index}]: position should be ${index + 1}, got ${item.position}`);
    }
    if (!item.name) {
      errors.push(`itemListElement[${index}]: Missing name`);
    }
    if (!item.item) {
      warnings.push(`itemListElement[${index}]: Missing item URL`);
    }
  });

  return {
    valid: errors.length === 0,
    errors,
    warnings,
  };
}

/**
 * Article Schema„ÇíÊ§úË®º
 */
function validateArticleSchema(data) {
  const errors = [];
  const warnings = [];

  if (data['@type'] !== 'Article') {
    errors.push('@type must be "Article"');
    return { valid: false, errors, warnings };
  }

  // ÂøÖÈ†à„Éï„Ç£„Éº„É´„Éâ
  if (!data.headline) errors.push('Missing required field: headline');
  if (!data.datePublished) warnings.push('Missing recommended field: datePublished');
  if (!data.author) warnings.push('Missing recommended field: author');

  return {
    valid: errors.length === 0,
    errors,
    warnings,
  };
}

/**
 * ÊßãÈÄ†Âåñ„Éá„Éº„Çø„ÇíÊ§úË®º
 */
function validateStructuredData(jsonLdArray, expectedTypes) {
  const results = [];

  jsonLdArray.forEach((data, index) => {
    const type = data['@type'];
    let validation;

    switch (type) {
      case 'Product':
        validation = validateProductSchema(data);
        break;
      case 'FAQPage':
        validation = validateFaqSchema(data);
        break;
      case 'BreadcrumbList':
        validation = validateBreadcrumbSchema(data);
        break;
      case 'Article':
        validation = validateArticleSchema(data);
        break;
      default:
        validation = {
          valid: true,
          errors: [],
          warnings: [`Unknown schema type: ${type}`],
        };
    }

    results.push({
      type,
      index,
      ...validation,
    });
  });

  return results;
}

/**
 * URL„ÇíÊ§úË®º
 */
async function validateUrl(url, verbose = false) {
  console.log(`\nüîç Testing: ${url}`);
  console.log('‚îÅ'.repeat(80));

  try {
    const html = await fetchHtml(url);
    const jsonLdArray = extractJsonLd(html);

    if (jsonLdArray.length === 0) {
      console.log('‚ùå No JSON-LD structured data found');
      return { success: false, url };
    }

    console.log(`‚úÖ Found ${jsonLdArray.length} JSON-LD script(s)`);

    const validations = validateStructuredData(jsonLdArray);

    let hasErrors = false;

    validations.forEach(({ type, index, valid, errors, warnings }) => {
      console.log(`\nüìÑ Schema #${index + 1}: ${type}`);

      if (valid) {
        console.log('   ‚úÖ Valid');
      } else {
        console.log('   ‚ùå Invalid');
        hasErrors = true;
      }

      if (errors.length > 0) {
        console.log('   \n   üö® Errors:');
        errors.forEach(err => console.log(`      - ${err}`));
      }

      if (warnings.length > 0) {
        console.log('   \n   ‚ö†Ô∏è  Warnings:');
        warnings.forEach(warn => console.log(`      - ${warn}`));
      }

      if (verbose) {
        console.log('\n   üìã Data:');
        console.log(JSON.stringify(jsonLdArray[index], null, 2).split('\n').map(line => `      ${line}`).join('\n'));
      }
    });

    return { success: !hasErrors, url };

  } catch (error) {
    console.log(`‚ùå Error: ${error.message}`);
    return { success: false, url, error: error.message };
  }
}

/**
 * „É°„Ç§„É≥Âá¶ÁêÜ
 */
async function main() {
  console.log('\nüöÄ Structured Data Validation Tool');
  console.log('‚îÅ'.repeat(80));

  let urlsToTest = [];

  // URL„ÅåÁõ¥Êé•ÊåáÂÆö„Åï„Çå„ÅüÂ†¥Âêà
  if (options.url) {
    urlsToTest = [options.url];
  }
  // „Çø„Ç§„Éó„ÅåÊåáÂÆö„Åï„Çå„ÅüÂ†¥Âêà
  else if (options.type) {
    const type = options.type.toLowerCase();
    if (TEST_URLS[type]) {
      urlsToTest = TEST_URLS[type].map(path => SITE_URL + path);
    } else {
      console.error(`‚ùå Unknown type: ${options.type}`);
      console.log(`Available types: ${Object.keys(TEST_URLS).join(', ')}`);
      process.exit(1);
    }
  }
  // „Éá„Éï„Ç©„É´„Éà: ÂÖ®„Å¶„ÉÜ„Çπ„Éà
  else {
    urlsToTest = Object.values(TEST_URLS)
      .flat()
      .map(path => SITE_URL + path);
  }

  console.log(`\nTesting ${urlsToTest.length} URL(s)...\n`);

  const results = [];

  for (const url of urlsToTest) {
    const result = await validateUrl(url, options.verbose);
    results.push(result);

    // „É¨„Éº„ÉàÂà∂ÈôêÂØæÁ≠ñÔºà500msÂæÖÊ©üÔºâ
    await new Promise(resolve => setTimeout(resolve, 500));
  }

  // „Çµ„Éû„É™„Éº
  console.log('\n\nüìä Summary');
  console.log('‚îÅ'.repeat(80));

  const successCount = results.filter(r => r.success).length;
  const failCount = results.filter(r => !r.success).length;

  console.log(`‚úÖ Passed: ${successCount}/${results.length}`);
  console.log(`‚ùå Failed: ${failCount}/${results.length}`);

  if (failCount > 0) {
    console.log('\nüö® Failed URLs:');
    results
      .filter(r => !r.success)
      .forEach(r => console.log(`   - ${r.url}`));
  }

  console.log('\n');

  // ÁµÇ‰∫Ü„Ç≥„Éº„Éâ
  process.exit(failCount > 0 ? 1 : 0);
}

main();
